#!/home/caoy7/anaconda2/envs/cLoops2/bin/python
#--coding:utf-8 --
"""

compareDom.py
cLoops2 compareDom.py quantify and compare Hi-C domains between two conditions.
2023-04-10: modified test without MA conversion
"""

__date__ = "2023-03-14"
__modified__ = ""
__email__ = "caoyaqiang0410@gmail.com"

#sys library
import os
import json
import argparse
from glob import glob
from argparse import RawTextHelpFormatter

#3rd library
import pylab
import HTSeq
import pandas as pd
import numpy as np
from tqdm import tqdm
from joblib import Parallel, delayed

#cLoops2
from cLoops2.est import estSfMANorm
from cLoops2.ds import XY
from cLoops2.io import parseIxy
from cLoops2.stat import twoPassesMDTest
from cLoops2.settings import *


def help():
    """
    Create the command line interface for the script.
    """
    description = """
        Pair-wise quantification and comparsion of domains based on two-passes Mahalanobis distance. 

        Example:
        compareDom.py -f dom.bed -a young -b old -o youngVsOld -na Young -b Old -pcut 0.01 -gtf mm10.gtf
        """
    parser = argparse.ArgumentParser(description=description,
                                     formatter_class=RawTextHelpFormatter)
    parser.add_argument("-f",
                        dest="domf",
                        required=True,
                        type=str,
                        help="Domain file in .bed format.")
    parser.add_argument(
        "-a",
        dest="da",
        required=True,
        type=str,
        help="The data directory generated by cLoops2 pre for the first sample."
    )
    parser.add_argument(
        "-b",
        dest="db",
        required=True,
        type=str,
        help=
        "The data directory generated by cLoops2 pre for the second sample.")
    parser.add_argument(
        "-na",
        dest="na",
        type=str,
        required=True,
        help=
        "Name of first sample, will be shown in the output figure. Only use alphabet and numbers."
    )
    parser.add_argument(
        "-nb",
        dest="nb",
        type=str,
        required=True,
        help="Name of second sample, will be shown in the output figure.")
    parser.add_argument(
        "-gtf",
        dest="gtf",
        default="",
        required=True,
        type=str,
        help=
        "GTF file annotation for genes. Significant flip/switch overlapped genes will be reported based on the gene annotation file."
    )
    parser.add_argument(
        "-pcut",
        dest="pcut",
        type=float,
        default=0.01,
        help=
        "Chi-Square p-value cutoff for detecting siginficant different compartment, default is 0.01."
    )

    parser.add_argument("-o",
                        dest="output",
                        required=True,
                        type=str,
                        help="Output prefix.")
    parser.add_argument(
        "-p",
        dest="cpu",
        required=False,
        type=int,
        default=4,
        help="How many cpus used for quantification, default is 4.")
    parser.add_argument(
        "-xlim",
        dest="xlim",
        required=False,
        type=str,
        default=None,
        help=
        "X-axis limitations for the scatter plot, default is autodetermined, set as '1,-1'."
    )
    parser.add_argument(
        "-ylim",
        dest="ylim",
        required=False,
        type=str,
        default=None,
        help=
        "Y-axis limitations for the scatter plot, default is autodetermined, set as '1,-1'."
    )
    parser.add_argument("-vmin",
                        dest="vmin",
                        required=False,
                        type=str,
                        default=None,
                        help="Minimal scale for the aggregation heatmap.")
    parser.add_argument("-vmax",
                        dest="vmax",
                        required=False,
                        type=str,
                        default=None,
                        help="Maxmal scale for the aggregation heatmap.")

    op = parser.parse_args()
    return op


def parseDom(f):
    doms = {}
    for line in open(f):
        if line[0] == "#":
            continue
        line = line.split("\n")[0].split("\t")
        if len(line) < 3:
            continue
        if line[0] not in doms:
            doms[line[0]] = []
        doms[line[0]].append(line)
    return doms


def _quant(rs, fixy, tot):
    ds = {}
    key, mat = parseIxy(fixy)
    xy = XY(mat[:, 0], mat[:, 1])
    for r in rs:
        key = r[0] + ":" + r[1] + "-" + r[2]
        t = xy.queryPeak(int(r[1]), int(r[2]))
        b = xy.queryPeakBoth(int(r[1]), int(r[2]))
        ds[key] = {
            "total":
            len(t),
            "internalCounts":
            len(b),
            "externalCounts":
            len(t.difference(b)),
            "ES(internal/external)":
            float(len(b)) / float(len(t.difference(b))),
            "internalRPKM":
            float(len(b)) / (int(r[2]) - int(r[1])) / tot * 10**9,
            "externalRPKM":
            float(len(t.difference(b))) / (int(r[2]) - int(r[1])) / tot *
            10**9,
        }
    return ds


def quant(d, doms, cpu):
    fs = glob(d + "/*.ixy")
    metaf = d + "/petMeta.json"
    meta = json.loads(open(metaf).read())
    tot = meta["Unique PETs"]
    nfs = {}
    for f in fs:
        c = f.split("/")[-1].split("-")[0]
        nfs[c] = f
    #get the data
    cs = list(doms.keys())
    ds = Parallel(n_jobs=cpu, backend="multiprocessing")(delayed(_quant)(
        doms[c],
        nfs[c],
        tot,
    ) for c in tqdm(cs))
    nds = {}
    for d in ds:
        for k, v in d.items():
            nds[k] = v
    ds = pd.DataFrame(nds).T
    return tot, ds


def summary(domsa, domsb, na, nb):
    data = {}
    for c in domsa.columns:
        data[na + "_" + c] = domsa[c]
        data[nb + "_" + c] = domsb[c]
    data = pd.DataFrame(data)
    return data


def plotChanges(data, na, nb, ra, rb, pcut, output, xlim=None, ylim=None):
    """
    Plot the domain changes with MA-plot.
    """
    sa = data[f"{na}_ES"]
    sb = data[f"{nb}_ES"]

    #plot the raw dots
    fig, ax = pylab.subplots(figsize=(3.2, 2.2))
    ax.scatter(sa,
               sb,
               s=0.5,
               color="gray",
               alpha=0.6,
               label="total %s domains" % data.shape[0])
    #plot the changes
    ax.scatter(sa[ra],
               sb[ra],
               s=2,
               color=colors[0],
               alpha=0.8,
               label="%s domains" % len(ra))
    ax.scatter(sa[rb],
               sb[rb],
               s=2,
               color=colors[1],
               alpha=0.8,
               label="%s domains" % len(rb))
    leg = ax.legend(bbox_to_anchor=(1.05, 1.0),
                    loc='upper left',
                    labelcolor=["gray", colors[0], colors[1]])
    for h in leg.legendHandles:
        h._sizes = [10]
    ax.set_xlabel(f"{na} domain ES")
    ax.set_ylabel(f"{nb} domain ES")
    ax.set_title(f"ES comparsion\nMahalanobis distance P-value < {pcut}")
    s = np.min([np.min(sa), np.min(sb)])
    e = np.max([np.max(sa), np.max(sb)])
    ax.plot([s, e], [s, e], color="gray", linestyle="--")
    if xlim is not None:
        xlim = list(map(float, xlim.split(",")))
        xlim.sort()
        ax.set_xlim(xlim)
    if ylim is not None:
        ylim = list(map(float, ylim.split(",")))
        ylim.sort()
        ax.set_ylim(ylim)
    pylab.savefig(f"{output}_domainChanges.pdf")


def writeBed(rs, fo):
    with open(fo, "w") as fout:
        for t in rs:
            chrom = t.split(":")[0]
            start = t.split(":")[1].split("-")[0]
            end = t.split(":")[1].split("-")[1]
            line = [chrom, start, end, t]
            fout.write("\t".join(line) + "\n")


def plotDiffAggDomains(fa, fb, tota, totb, na, nb, fout, vmin=None, vmax=None):
    mata = np.load(fa, mmap_mode="r")
    mata = mata["arr_0"]
    matb = np.load(fb, mmap_mode="r")
    matb = matb["arr_0"]
    ta = tota / 10**6
    tb = totb / 10**6
    mata = np.log2((mata + 1) / ta)
    matb = np.log2((matb + 1) / tb)
    mat = []
    for i in range(mata.shape[0]):
        atmat = mata[i]
        btmat = matb[i]
        nmat = btmat - atmat
        mat.append(nmat)
    mat = np.array(mat)
    mat = np.mean(mat, axis=0)
    label = f"normalized log2({nb}/{na})"
    #if vmin == None:
    #    vmin = 0
    fig, ax = pylab.subplots(figsize=(4, 4))
    cmap = sns.color_palette("RdBu_r", 11).as_hex()
    cmap[int(len(cmap) / 2)] = "#FFFFFF"
    cmap = ListedColormap(cmap)
    sns.heatmap(mat,
                xticklabels=False,
                yticklabels=False,
                square=True,
                linewidths=0.0,
                vmin=vmin,
                vmax=vmax,
                cmap=cmap,
                cbar_kws={
                    'label': label,
                    "shrink": 0.5
                })
    #draw the box
    ax.axvline(x=ax.get_xlim()[0], color="k", linewidth=2)
    ax.axvline(x=ax.get_xlim()[1], color="k", linewidth=2)
    ax.axhline(y=ax.get_ylim()[0], color="k", linewidth=2)
    ax.axhline(y=ax.get_ylim()[1], color="k", linewidth=2)
    ax.set_title("log2(%s-%s) %s domains" % (nb, na, mata.shape[0]))
    pylab.savefig("%s_diffAggDomains.pdf" % fout)


def parseGtfFeature(t):
    ds = {}
    t = t.replace('"', '')
    for n in t.split('; '):
        s = n.split()
        ds[s[0]] = s[1]
    return ds


def readGenes(gtf):
    """
    Read gene sets regions as HTSeq.GenomicArrayOfSets.
    """
    #read gtf
    genes = HTSeq.GenomicArrayOfSets("auto", stranded=False)
    gs = {}
    for line in open(gtf):
        if line.startswith("#"):
            continue
        line = line.split("\n")[0].split("\t")
        if line[2] != 'exon':
            continue
        ds = parseGtfFeature(line[8])
        key = "|".join([ds["gene_id"], ds["gene_name"]])
        nline = [
            line[0], line[3], line[4],
            "|".join([ds["gene_id"], ds["gene_name"]]), ".", line[6]
        ]
        if key not in gs:
            gs[key] = [line[0], int(line[3]), int(line[4])]
        else:
            if int(line[3]) < gs[key][1]:
                gs[key][1] = int(line[3])
            if int(line[4]) > gs[key][2]:
                gs[key][2] = int(line[4])
    for g, v in gs.items():
        iv = HTSeq.GenomicInterval(v[0], v[1], v[2])
        genes[iv] += g
    return genes


def anoBins(data, na, nb, s, genes, fout):
    """
    Annotate changed bins.
    """
    ds = {}
    ags = set()
    for t in s:
        chrom = t.split(":")[0]
        start = t.split(":")[1].split("-")[0]
        end = t.split(":")[1].split("-")[1]
        iv = HTSeq.GenomicInterval(chrom, int(start), int(end))
        gs = set()
        for i, g in genes[iv].steps():
            gs.update(g)
        gs = list(gs)
        if len(gs) > 0:
            gs = [g.split("|")[-1] for g in gs]
        ags.update(gs)
        gs = ",".join(gs)
        ds[t] = {
            "chrom": chrom,
            "start": start,
            "end": end,
            "overlappedGenes": gs,
        }
        for c in data.columns:
            ds[t][c] = data.loc[t, c]
    ds = pd.DataFrame(ds).T
    ds.to_csv(fout + ".txt", index_label="domId", sep="\t")
    ags = list(ags)
    with open(fout + "_genes.list", "w") as fo:
        fo.write("\n".join(ags))


def compareDom(
        domf,
        da,
        db,
        na,
        nb,
        gtf,
        output,
        pcut=0.01,
        cpu=4,
        xlim=None,
        ylim=None,
        vmin=None,
        vmax=None,
):
    """
    Pair-wise comparsion of domains. 

    @param domf: str, domains in bed format, file path
    @param da: str, cLoops2 pre generated data directory for the first sample
    @param db: str, cLoops2 pre generated data directory for the second sample
    @param na: str, name of the first sample
    @param nb: str, name of the second sample
    @param gtf: str, file path of the gtf annotaiton file 
    @param output: str, output prefix
    @param pcut: float, p-value cutoff for the two-passes MD test 
    @param cpu: int, number of CPUs for running the job.
    """

    print("Step 1: Quantifying domains.")
    #step 1 quantify the domains
    doms = parseDom(domf)
    tota, domsa = quant(da, doms, cpu)
    totb, domsb = quant(db, doms, cpu)
    data = summary(domsa, domsb, na, nb)
    data.to_csv(f"{output}_domainQuant.txt", sep="\t", index_label="domId")
    #data = pd.read_csv(f"{output}_domainQuant.txt", index_col=0, sep="\t")

    #step 2 pair-wise comparsion
    print("Step 2: Performing two-passes mahalanobis distances caculation.")
    #use the ES with MA plot to run the two-passes MD test
    sa = data[f"{na}_ES(internal/external)"]
    sb = data[f"{nb}_ES(internal/external)"]

    a = (sa + sb) / 2
    m = np.log2(sb / sa)
    """
    #MANorm2
    sf = estSfMANorm(sa, sb)
    sbn = pd.Series( [sf[0]*t + sf[1] for t in sb],index=sb.index )
    a = (sa+sbn )/2
    m = np.log2(sbn/sa)
    """

    #esdata = pd.DataFrame({"A": a, "M": m})
    esdata = pd.DataFrame({f"{na}_ES": sa, f"{nb}_ES": sb})
    dis, ps = twoPassesMDTest(esdata, pcut)
    ps[ps < 1e-300] = 1e-300
    inds = ps[ps < pcut].index
    esdata["Mahalanobis distance"] = dis
    esdata["Chi-Square test P-value"] = ps
    esdata.to_csv(f"{output}_ES_MD_p-values.txt",
                  sep="\t",
                  index_label="domId")
    ra = sa[sa > sb].index.intersection(inds)
    ra = m[ra].sort_values(inplace=False, ascending=True).index
    rb = sb[sb > sa].index.intersection(inds)
    rb = m[rb].sort_values(inplace=False, ascending=False).index

    #data["ES_M"] = esdata["M"]
    #data["ES_A"] = esdata["A"]
    data["Mahalanobis distance"] = esdata["Mahalanobis distance"]
    data["Chi-Square test P-value"] = esdata["Chi-Square test P-value"]
    data = pd.read_csv(f"{output}_domainQuant.txt", index_col=0, sep="\t")

    #step 3 show the changes
    plotChanges(esdata, na, nb, ra, rb, pcut, output, xlim, ylim)

    #step 4 output the bed files
    writeBed(ra, f"{output}_{na}_specific.bed")
    writeBed(rb, f"{output}_{nb}_specific.bed")

    print("Step 3: Performing aggregation analysis.")
    #step 5 plot the aggregation plots
    c1 = f"cLoops2 agg -d {da} -domains {output}_{na}_specific.bed -o {output}_{na}_specific_{na} -p {cpu} -domain_ext 0.25"
    c2 = f"cLoops2 agg -d {db} -domains {output}_{na}_specific.bed -o {output}_{na}_specific_{nb} -p {cpu} -domain_ext 0.25"
    c3 = f"cLoops2 agg -d {da} -domains {output}_{nb}_specific.bed -o {output}_{nb}_specific_{na} -p {cpu} -domain_ext 0.25"
    c4 = f"cLoops2 agg -d {db} -domains {output}_{nb}_specific.bed -o {output}_{nb}_specific_{nb} -p {cpu} -domain_ext 0.25"
    for c in [c1, c2, c3, c4]:
        print(c)
        os.system(c)
    plotDiffAggDomains(f"{output}_{na}_specific_{na}_aggDomains.npz",
                       f"{output}_{na}_specific_{nb}_aggDomains.npz", tota,
                       totb, na, nb, f"{output}_{na}_specific", vmin, vmax)
    plotDiffAggDomains(f"{output}_{nb}_specific_{na}_aggDomains.npz",
                       f"{output}_{nb}_specific_{nb}_aggDomains.npz", tota,
                       totb, na, nb, f"{output}_{nb}_specific", vmin, vmax)

    #step 6 annotate the domains
    print("Step 4: Annotating specific domains.")
    genes = readGenes(gtf)
    anoBins(data, na, nb, ra, genes, f"{output}_{na}_specificDomains")
    anoBins(data, na, nb, rb, genes, f"{output}_{nb}_specificDomains")

    print("Finished")


def main():
    op = help()
    compareDom(op.domf, op.da, op.db, op.na, op.nb, op.gtf, op.output, op.pcut,
               op.cpu, op.xlim, op.ylim, op.vmin, op.vmax)


if __name__ == "__main__":
    main()
